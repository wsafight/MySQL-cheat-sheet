import{_ as t,c as r,b as a,o as s}from"./app--XYqrjBE.js";const n="/server-study-notes/assets/B_treevisualization-CGve1t99.png",o={};function p(l,e){return s(),r("div",null,e[0]||(e[0]=[a('<h1 id="实现-b-树" tabindex="-1"><a class="header-anchor" href="#实现-b-树"><span>实现 B+ 树</span></a></h1><p>我们都知道，InnoDB 引擎使用了 B+ 树作为索引。而数据在不断插和删除的过程会变化高度。那么 B+ 树在层级变化时候为什么不会出现性能呢问题？</p><p>先说结论，按照主键自增的情况。B+ 树层级变化只会影响上层索引和对应叶子结点的数据。而 B+ 树索引的上层是常驻内存的，所以不会出现性能问题。当前分析不会涉及 MySQL 源码。</p><p>我们可以先看一下对应示例的 <a href="https://visual-algo.firebaseapp.com/" target="_blank" rel="noopener noreferrer">B+tree visualization</a>,通过不断模拟增加减少，我们就可以看出修改的结点数据。</p><p><img src="'+n+'" alt="B+ +tree visualization"></p><p>代码实现在 <a href="https://github.com/wsafight/b-plus-tree" target="_blank" rel="noopener noreferrer">b-plus-tree</a> 中，完成后会进行源码解读。</p>',6)]))}const c=t(o,[["render",p],["__file","b-plus-tree.html.vue"]]),m=JSON.parse('{"path":"/mysql/performance/b-plus-tree.html","title":"实现 B+ 树","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"updatedTime":1691597410000,"contributors":[{"name":"wsafight","email":"984292420@qq.com","commits":4}]},"filePathRelative":"mysql/performance/b-plus-tree.md"}');export{c as comp,m as data};
