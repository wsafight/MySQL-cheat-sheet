import{_ as a,c as l,b as n,o as i}from"./app--XYqrjBE.js";const s={};function h(d,e){return i(),l("div",null,e[0]||(e[0]=[n(`<h1 id="使用守则" tabindex="-1"><a class="header-anchor" href="#使用守则"><span>使用守则</span></a></h1><p>缓存作为互联网应用至关重要的基础组件之一，每天承载着巨大的业务请求量。一旦缓存出现故障，对业务的影响将非常严重。因此，必须要确保缓存的稳定性。</p><p>下面是缓存使用的守则。</p><h3 id="key-尽量保持简洁性、可读性、可管理性" tabindex="-1"><a class="header-anchor" href="#key-尽量保持简洁性、可读性、可管理性"><span>key 尽量保持简洁性、可读性、可管理性</span></a></h3><p>在保证语义的前提下，控制 key 的长度。</p><p>比如：以业务名 (或数据库名) 为前缀 (防止 key 冲突)，用冒号分隔，同时不要包含特殊字符。如</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line">业务名:表名:id </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="不要出现-bigkey" tabindex="-1"><a class="header-anchor" href="#不要出现-bigkey"><span>不要出现 bigkey</span></a></h3><p>查询 bigkey 会导致流量过高。如果出现限流，会导致业务不可用。</p><p>string 类型控制在 10 KB 以内，hash、list、set、zset 元素个数不要超过 5000 个</p><h3 id="尽量不使用全量操作命令" tabindex="-1"><a class="header-anchor" href="#尽量不使用全量操作命令"><span>尽量不使用全量操作命令</span></a></h3><p>禁用 <code>keys *</code> 命令，不使用 hgetall、smembers 等命令。在获取 key 下的多个元素时，使用对应数据结构的 scan 命令，一次获取少量元素，分多次获取，一次 scan 不要超过 200 个。</p><h3 id="控制-key-生命周期" tabindex="-1"><a class="header-anchor" href="#控制-key-生命周期"><span>控制 key 生命周期</span></a></h3><p>最好对 key 都设置过期时间，并且将 key 的 ttl 打散，避免 key 集中过期出现业务问题。</p><h3 id="避免热点-key" tabindex="-1"><a class="header-anchor" href="#避免热点-key"><span>避免热点 key</span></a></h3><p>热 key 会导致数据倾斜，还有可能导致单节点压力过大。建议业务侧将热 key 打散。</p><h3 id="限制单次操作元素数量" tabindex="-1"><a class="header-anchor" href="#限制单次操作元素数量"><span>限制单次操作元素数量</span></a></h3><p>限制 mset、mget、hmset、hmget、*scan、*range 等命令单次操作元素数量，建议不要超过 200。</p><h3 id="使用-unlink-删除" tabindex="-1"><a class="header-anchor" href="#使用-unlink-删除"><span>使用 unlink 删除</span></a></h3><p>Redis 删除 key 时，不要用 del 命令，使用 unlink 命令。unlink 命令可以异步删除 key，减少删除操作的阻塞时间，不会对 Redis 主线程产生影响。</p><p>如：del 一个大 key 会直接导致 Redis 卡住。unlink 不会出现这种问题。</p><h3 id="使用合成命令" tabindex="-1"><a class="header-anchor" href="#使用合成命令"><span>使用合成命令</span></a></h3><p>使用 setex 而不是 set 和 expire 命令，减少服务端写压力。</p><h3 id="采用高效序列化方法和压缩方法" tabindex="-1"><a class="header-anchor" href="#采用高效序列化方法和压缩方法"><span>采用高效序列化方法和压缩方法</span></a></h3><p>如果 value 较大时，使用压缩工具（如 snappy 或 gzip），把数据压缩后再写入缓存。</p><h3 id="避免批量任务、定时任务、周期任务流量太大影响在线业务" tabindex="-1"><a class="header-anchor" href="#避免批量任务、定时任务、周期任务流量太大影响在线业务"><span>避免批量任务、定时任务、周期任务流量太大影响在线业务</span></a></h3><p>批量任务、定时任务、周期任务业务中要做限速</p><h3 id="避免多业务复用同一缓存资源" tabindex="-1"><a class="header-anchor" href="#避免多业务复用同一缓存资源"><span>避免多业务复用同一缓存资源</span></a></h3><p>不同业务的数据使用不同的集群，过多业务复用同一资源要做拆分。业务尽量提供 rpc 接口给其它业务调用，而不是直接让其它业务访问数据源（如一个业务写，另一个业务读）</p><h3 id="控制-pipeline" tabindex="-1"><a class="header-anchor" href="#控制-pipeline"><span>控制 pipeline</span></a></h3><p>控制 pipeline 中命令的数量，不要超过 100 条</p><h3 id="使用-evalsha-代替-eval" tabindex="-1"><a class="header-anchor" href="#使用-evalsha-代替-eval"><span>使用 evalsha 代替 eval</span></a></h3><p>evalsha 会执行缓存在服务器端的脚本。减少网络 IO，同时也减小 Redis 网络 IO 压力，提高缓存性能。</p><h3 id="redis-不要使用逻辑-db-只使用默认-db-0" tabindex="-1"><a class="header-anchor" href="#redis-不要使用逻辑-db-只使用默认-db-0"><span>Redis 不要使用逻辑 db，只使用默认 db 0</span></a></h3><p>可以通过实例隔离，不同业务的数据保存到不同的实例中。（只有 Redis 主从可以选择逻辑 db，集群模式默认都使用 db0）</p><h3 id="减少-lua-脚本使用" tabindex="-1"><a class="header-anchor" href="#减少-lua-脚本使用"><span>减少 lua 脚本使用</span></a></h3><p>集群模式对 lua 支持有限制，必须保证 lua 中操作的 key 被 sharding 到同一个节点。所以尽量减少对 lua 的使用</p><h3 id="lua-脚本中不跑复杂逻辑" tabindex="-1"><a class="header-anchor" href="#lua-脚本中不跑复杂逻辑"><span>lua 脚本中不跑复杂逻辑</span></a></h3><p>复杂逻辑放在业务代码中，而不是 lua 脚本中。</p>`,39)]))}const p=a(s,[["render",h],["__file","regulations.html.vue"]]),t=JSON.parse('{"path":"/redis/notes/regulations.html","title":"使用守则","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"key 尽量保持简洁性、可读性、可管理性","slug":"key-尽量保持简洁性、可读性、可管理性","link":"#key-尽量保持简洁性、可读性、可管理性","children":[]},{"level":3,"title":"不要出现 bigkey","slug":"不要出现-bigkey","link":"#不要出现-bigkey","children":[]},{"level":3,"title":"尽量不使用全量操作命令","slug":"尽量不使用全量操作命令","link":"#尽量不使用全量操作命令","children":[]},{"level":3,"title":"控制 key 生命周期","slug":"控制-key-生命周期","link":"#控制-key-生命周期","children":[]},{"level":3,"title":"避免热点 key","slug":"避免热点-key","link":"#避免热点-key","children":[]},{"level":3,"title":"限制单次操作元素数量","slug":"限制单次操作元素数量","link":"#限制单次操作元素数量","children":[]},{"level":3,"title":"使用 unlink 删除","slug":"使用-unlink-删除","link":"#使用-unlink-删除","children":[]},{"level":3,"title":"使用合成命令","slug":"使用合成命令","link":"#使用合成命令","children":[]},{"level":3,"title":"采用高效序列化方法和压缩方法","slug":"采用高效序列化方法和压缩方法","link":"#采用高效序列化方法和压缩方法","children":[]},{"level":3,"title":"避免批量任务、定时任务、周期任务流量太大影响在线业务","slug":"避免批量任务、定时任务、周期任务流量太大影响在线业务","link":"#避免批量任务、定时任务、周期任务流量太大影响在线业务","children":[]},{"level":3,"title":"避免多业务复用同一缓存资源","slug":"避免多业务复用同一缓存资源","link":"#避免多业务复用同一缓存资源","children":[]},{"level":3,"title":"控制 pipeline","slug":"控制-pipeline","link":"#控制-pipeline","children":[]},{"level":3,"title":"使用 evalsha 代替 eval","slug":"使用-evalsha-代替-eval","link":"#使用-evalsha-代替-eval","children":[]},{"level":3,"title":"Redis 不要使用逻辑 db，只使用默认 db 0","slug":"redis-不要使用逻辑-db-只使用默认-db-0","link":"#redis-不要使用逻辑-db-只使用默认-db-0","children":[]},{"level":3,"title":"减少 lua 脚本使用","slug":"减少-lua-脚本使用","link":"#减少-lua-脚本使用","children":[]},{"level":3,"title":"lua 脚本中不跑复杂逻辑","slug":"lua-脚本中不跑复杂逻辑","link":"#lua-脚本中不跑复杂逻辑","children":[]}],"git":{"updatedTime":1718847432000,"contributors":[{"name":"jump-and-jump","email":"984292420@qq.com","commits":1},{"name":"wsafight","email":"984292420@qq.com","commits":1}]},"filePathRelative":"redis/notes/regulations.md"}');export{p as comp,t as data};
