import{_ as n,c as a,b as e,o as l}from"./app--XYqrjBE.js";const i={};function p(d,s){return l(),a("div",null,s[0]||(s[0]=[e('<h1 id="索引优化" tabindex="-1"><a class="header-anchor" href="#索引优化"><span>索引优化</span></a></h1><p>1.维度高的列创建索引</p><p>数据列中不重复值出现的个数,这个数量越高,维度就越高 如数据表中存在8行数据a ,b ,c,d,a,b,c,d这个表的维度为4 要为维度高的列创建索引,如性别和年龄,那年龄的维度就高于性别 性别这样的列不适合创建索引,因为维度过低</p><p>2.对 where,on,group by,order by 中出现的列使用索引</p><p>3.对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键</p><p>4.为较长的字符串使用前缀索引</p><p>5.不要过多创建索引,除了增加额外的磁盘空间外,对于DML操作的速度影响很大,因为其每增删改一次就得从新建立索引</p><p>6.使用组合索引,可以减少文件索引大小,在使用时速度要优于多个单列索引</p><div class="language-sqL line-numbers-mode" data-highlighter="prismjs" data-ext="sqL" data-title="sqL"><pre><code><span class="line">SELECT `sname` FROM `stu` WHERE `age`+10=30;-- 不会使用索引,因为所有索引列参与了计算</span>\n<span class="line"></span>\n<span class="line">SELECT `sname` FROM `stu` WHERE LEFT(`date`,4) &lt;1990; -- 不会使用索引,因为使用了函数运算,原理与上面相同</span>\n<span class="line"></span>\n<span class="line">SELECT * FROM `houdunwang` WHERE `uname` LIKE&#39;后盾%&#39; -- 走索引</span>\n<span class="line"></span>\n<span class="line">SELECT * FROM `houdunwang` WHERE `uname` LIKE &quot;%后盾%&quot; -- 不走索引</span>\n<span class="line"></span>\n<span class="line">-- 正则表达式不使用索引,这应该很好理解,所以为什么在SQL中很难看到regexp关键字的原因</span>\n<span class="line"></span>\n<span class="line">-- 字符串与数字比较不使用索引;</span>\n<span class="line">CREATE TABLE `a` (`a` char(10));</span>\n<span class="line">EXPLAIN SELECT * FROM `a` WHERE `a`=&quot;1&quot; -- 走索引</span>\n<span class="line">EXPLAIN SELECT * FROM `a` WHERE `a`=1 -- 不走索引</span>\n<span class="line"></span>\n<span class="line">select * from dept where dname=&#39;xxx&#39; or loc=&#39;xx&#39; or deptno=45 --如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引, 我们建议大家尽量避免使用or 关键字</span>\n<span class="line"></span>\n<span class="line">-- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前缀索引兼顾索引大小和查询速度</p><p>组合索引</p><p>vc_Name,vc_City,i_Age vc_Name,vc_City vc_Name</p><p>只是在大数据导入时,可以先删除索引,再批量插入数据,最后再添加索引;</p><p>使用查询提示</p><ul><li>USE INDEX</li><li>FORCE INDEX</li><li>iGNORE INDEX</li></ul><p>使用 USE 提示会让 MySOL 从指定的索引中选择一个。FORCE 会对基于开销的优化器产生影响，让优化器更倾向于索引扫描而不是全表扫描。</p><p>添加或者改变表上的索引并不会影响到 一个在特定索引中指 定的硬编码 SQL 语句，所以查询提示应该是你最后考虑的方案。</p><p>频繁执行且速度很快的 SQL 语句通常被认为不是必须要调整的。但提升这些查询的速度能够为系统资源带来非常大的益处， 这些资源使得你的数据库系统能够处理更多的 SQL 语句。</p><p>SHOW INDEX STATISTICS 是谷歌的一个补丁，收集 sql 语句并监控引擎使用。</p><p>[mysqld] 全面查询日志 general_log=1 general_log_file=/path/to/file</p><p>慢 sql 日志 slow_query_log=1 slow_query_log_file=/path/to/file long_query_time=0.2 log_output=FILE</p><p>二进制日志 log_bin=/path/to/file</p>',22)]))}const r=n(i,[["render",p],["__file","database-index.html.vue"]]),t=JSON.parse('{"path":"/mysql/performance/database-index.html","title":"索引优化","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"updatedTime":1691424102000,"contributors":[{"name":"wsafight","email":"984292420@qq.com","commits":1}]},"filePathRelative":"mysql/performance/database-index.md"}');export{r as comp,t as data};
