import{_ as n,c as s,b as a,o as i}from"./app--XYqrjBE.js";const l={};function r(t,e){return i(),s("div",null,e[0]||(e[0]=[a('<h1 id="利用多台-mysql-服务器产生分布式-id" tabindex="-1"><a class="header-anchor" href="#利用多台-mysql-服务器产生分布式-id"><span>利用多台 MySQL 服务器产生分布式 id</span></a></h1><p>MySQL 可以产生自增ID，利用多台 MySQL 服务器也可以组成一个高性能的分布式发号器。</p><p>假设用 8 台 MySQL 服务器协同工作，第一台 MySQL 初始值是1，每次自增8，第二台 MySQL 初始值是 2，每次自增 8，依次类推。前面用一个 round-robin load balancer 挡着，每来一个请求，由 round-robin balancer 随机地将请求发给 8 台 MySQL 中的任意一个，然后返回一个 ID。</p><p><a href="https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener noreferrer">Flickr 票务服务使用了这中方案</a>。Flickr 票务服务器是一个专用的数据库服务器，上面只有一个数据库，在该数据库中有用于 32 位 ID 数据表 Tickets32 和用于 64 位 ID 的数据表 Tickets64。</p><p>该方案的缺点是缺点是 ID 是不是严格递增的，只是粗略递增的。</p><h2 id="创建数据表数据表" tabindex="-1"><a class="header-anchor" href="#创建数据表数据表"><span>创建数据表数据表</span></a></h2><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">CREATE TABLE `tbl_name` {</span>\n<span class="line">    `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,</span>\n<span class="line">    `row_name` char(1) NOT NULL DEFAULT &#39;&#39;,</span>\n<span class="line">    PRIMARY KEY (`id`),</span>\n<span class="line">    UNIQUE KEY `row_name` (`row_name`)</span>\n<span class="line">} ENGINE=InnoDB</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每次我们想要生成并获取 id 时。利用 REPLACE INTO 生成新的 ID。执行如下所示</p><div class="language-SQL line-numbers-mode" data-highlighter="prismjs" data-ext="SQL" data-title="SQL"><pre><code><span class="line">REPLACE INTO `tbl_name` (`row_name`) VALUES (&#39;a&#39;)</span>\n<span class="line">SELECT LAST_INSERT_ID()</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>auto_increment_offset表示自增长字段从那个数开始，他的取值范围是1 .. 65535</li><li>auto_increment_increment表示自增长字段每次递增的量，其默认值是1，取值范围是1 .. 65535</li></ul><p>如果有两台服务器设定如下所示</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Server 1:</span>\n<span class="line">auto-increment-increment = 2</span>\n<span class="line">auto-increment-offset = 1</span>\n<span class="line"></span>\n<span class="line">Server 2:</span>\n<span class="line">auto-increment-increment = 2</span>\n<span class="line">auto-increment-offset = 2</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',12)]))}const c=n(l,[["render",r],["__file","uid.html.vue"]]),p=JSON.parse('{"path":"/mysql/notes/uid.html","title":"利用多台 MySQL 服务器产生分布式 id","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"创建数据表数据表","slug":"创建数据表数据表","link":"#创建数据表数据表","children":[]}],"git":{"updatedTime":1691424102000,"contributors":[{"name":"wsafight","email":"984292420@qq.com","commits":1}]},"filePathRelative":"mysql/notes/uid.md"}');export{c as comp,p as data};
